name: Silicon Labs firmware build

on:
  push:
    paths:
      - Dockerfile
      - .github/workflows/build.yaml
      - .github/workflows/silabs-firmware-build.yaml
      - .github/workflows/silabs-firmware-build-zwave.yaml
      - EmberZNet/**
      - OpenThreadRCP/**
      - RCPMultiPAN/**
      - ZWave/**
    branches:
      - main
    tags:
      - '*'

jobs:
  build-container:
    name: Create build container image
    runs-on: ubuntu-latest
    permissions:
      packages: write
    outputs:
      image_name: ghcr.io/${{ steps.lower.outputs.repository_owner }}/silabs-firmware-builder:${{ hashFiles("Dockerfile") }}
    steps:
      - name: Repository owner lowercase
        id: lower
        run: |
          echo "repository_owner=$(echo $GITHUB_REPOSITORY_OWNER | tr [:upper:] [:lower:])" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v3.3.0
      - name: Log in to the GitHub container registry
        uses: docker/login-action@v2.1.0
        with:
            registry: ghcr.io
            username: ${{ github.repository_owner }}
            password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2.2.1
      - name: Build and Push
        uses: docker/build-push-action@v5.1.0
        with:
          context: .
          file: Dockerfile
          tags: ghcr.io/${{ steps.lower.outputs.repository_owner }}/silabs-firmware-builder:${{ hashFiles("Dockerfile") }}
          cache-from: ghcr.io/${{ steps.lower.outputs.repository_owner }}/silabs-firmware-builder:cache-${{ hashFiles("Dockerfile") }}
          cache-to: ghcr.io/${{ steps.lower.outputs.repository_owner }}/silabs-firmware-builder:cache-${{ hashFiles("Dockerfile") }}
          push: true

  list-manifests:
    name: List firmware manifests
    needs: build-container
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3.3.0
      - id: set-matrix
        run: echo "::set-output name=matrix::$(ls manifests/**/*.yaml | jq -R -s -c 'split("\n")[:-1]')"

  build-firmwares:
    name: Firmware builder
    runs-on: ubuntu-latest
    strategy:
      matrix:
        manifest: ${{ fromJson(needs.list-manifests.outputs.matrix) }}
    container:
      options: --user root
    defaults:
      run:
        shell: su --shell=/bin/bash builder {0}
    steps:
      - uses: actions/checkout@v3.3.0

      - name: Read firmware manifest
        uses: pietrobolcato/action-read-yaml@1.0.0
        id: read_manifest_yaml
        with:
          config: ${{ matrix.manifest }}

      - name: Adjust permission
        shell: bash
        run: chown builder .

      - name: Install SDK extensions
        shell: bash
        run: |
          # XXX: slc-cli does not actually work when the extensions aren't in the SDK!
          for sdk in /gecko_sdk_*; do
            ln -s $PWD/gecko_sdk_extensions "$sdk"/extension

            for ext in "$sdk"/extension/*/; do
              slc signature trust --extension-path="$ext"
            done
          done

      - name: Build firmware
        shell: bash
        run: |
          filename_with_extension="${${{ matrix.manifest }}##*/}"
          filename="${filename_with_extension%%.*}"

          # Pass all SDKs as consecutive `--sdk ...` arguments
          sdk_args=""

          for sdk_dir in /gecko_sdk*; do
            sdk_args="$sdk_args --sdk \"$sdk_dir\""
          done

          # Build it
          mkdir outputs
          python tools/generate_project.py \
            $sdk_args
            --manifest "${{ matrix.manifest }}" \
            --build-dir build \
            --build-system make \
            --output "gbl:outputs/$filename.gbl" \
            --output "hex:outputs/$filename.hex" \
            --output "out:outputs/$filename.out"

      - name: Install node within container (act)
        if: ${{ env.ACT }}
        shell: bash
        run: |
            curl -fsSL https://deb.nodesource.com/nsolid_setup_deb.sh | bash -s 20
            apt-get install -y nodejs

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.read_manifest_yaml.outputs['name'] }}
          path: outputs/*
